%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int yylex(void);
void yyerror(const char *s);
extern FILE *yyin;
extern int yylineno;

%}

%union {
    int number;
    double fnumber;
    char *string;
}

/* Приоритеты операторов */
%nonassoc LOWER_THAN_ELSE
%nonassoc SKULL
%right ZAP
%left BULB LINK /* && */ /* || */
%left FIRE SNOWFLAKE SUN MOON   /* == != > < */
%left BOOM SHIELD   /* + - */
%left STAR DROPLET  /* * / */
%right NO_ENTRY     /* ! */
%left RAILWAY_TRACK  /* [] - самый высокий приоритет */ 
%nonassoc ARRAY_INDEX

/* Токены */
%token PRIMO GEM NOTE BRAIN SPARKLES
%token BOOM SHIELD STAR DROPLET ZAP FIRE SNOWFLAKE SUN MOON BULB LINK NO_ENTRY
%token CHAK
%token CROWN CYCLONE INFINITY DART SKULL COLLISION LOOP BACK GHOST
%token MEGA EAR HEART BROKEN_HEART MUSCLE BONE TRULER ERROR
%token <number> NUMBER TRUE FALSE
%token <fnumber> FLOAT
%token <string> IDENT /*второе - имя идентификатора, первое - тип*/
%token <string> STRING CHAR
%token IN DOTDOT DOTDOTLT STEP
%token LOCOMOTIVE STEAM_LOCOMOTIVE RAILWAY_TRACK  
%token SIN COS

/* Типы нетерминалов */
%type <string> program functions /*function*/ main_func user_func
%type <string> type params param_list param
%type <string> block stmts stmt
%type <string> decl assign cond_stmt loop init cond_expr step //cond
%type <string> print input ret CTRL
%type <string> printItems printItem
%type <string> expr primary
%type <string> semicolon
%type <string> functionCall callParams exprList main_block
%type <string> range_loop foreach_loop array_decl array_init array_index_chain //array_access
%type <string> user_funcs

%%

program:
    functions
    {
        //printf("/* Everything compiled successfully! */\n");
        //extern int yynerrs;
        //if (yynerrs == 0) {
        //    printf("/* Everything compiled successfully! */\n");
        //} else {
        //    printf("\n/* Compilation failed with %d errors */\n", yynerrs);
        //}
        ////сделать как было наверное а то не работает чего-то
    }
    ;

//functions:
//    function
//    | functions function
//    ;

//function:
//    main_func
//    | user_func
//    ;

functions:
    user_funcs main_func
    {
        printf("/*******************************************\n");
        printf("Generated by BrawlF Compiler\n");
        printf("*******************************************/\n\n");
        printf("#include <stdio.h>\n");
        printf("#include <stdbool.h>\n");
        printf("#include <string.h>\n");
        printf("#include <math.h>\n\n");
        printf("%s", $1);  // user функции
        printf("%s", $2);  // main
        free($1); free($2);
    }
    ;

user_funcs:
    /* empty */ { $$ = strdup(""); }
    | user_funcs user_func
    {
        $$ = malloc(strlen($1) + strlen($2) + 1);
        sprintf($$, "%s%s", $1, $2);
        free($1); free($2);
    }
    ;


main_func:
    CROWN HEART BROKEN_HEART main_block
    {
        //printf("/*******************************************\n");
        //printf("Generated by BrawlF Compiler\n");
        //printf("*******************************************/\n\n");
        //printf("#include <stdio.h>\n");
        //printf("#include <stdbool.h>\n");
        //printf("#include <string.h>\n\n");
        //printf("#include <math.h>\n\n");
        

        //printf("int main() %s\n\n", $4);
        $$ = malloc(strlen($4) + 20);
        sprintf($$, "int main() %s\n\n", $4);
        free($4);
    }
    ;

user_func:
    type IDENT HEART params BROKEN_HEART block
    {
        //printf("%s %s(%s) %s\n\n", $1, $2, $4, $6);

        $$ = malloc(strlen($1) + strlen($2) + strlen($4) + strlen($6) + 10);
        sprintf($$, "%s %s(%s) %s\n\n", $1, $2, $4, $6);
        //free($1); free($2); free($4); free($6);
        free($1); free($2); free($4); free($6);
    }
    ;

type:
    PRIMO { $$ = strdup("int"); }
    | GEM { $$ = strdup("double"); }
    | NOTE { $$ = strdup("char"); }
    | BRAIN { $$ = strdup("bool"); }
    | SPARKLES { $$ = strdup("char*"); }
    | GHOST { $$ = strdup("void"); }
    ;

params:
    /* empty */ { $$ = strdup(""); }
    | param_list { $$ = $1; }
    ;

param_list:
    param
    | param_list TRULER param
    {
        $$ = malloc(strlen($1) + strlen($3) + 3);
        sprintf($$, "%s, %s", $1, $3);
        free($1); free($3);
    }
    ;

param:
    type IDENT
    {
        $$ = malloc(strlen($1) + strlen($2) + 2);
        sprintf($$, "%s %s", $1, $2);
        free($1); free($2);
    }
    ;

main_block:
    MUSCLE stmts BONE
    {
        $$ = malloc(strlen($2) + 20);
        sprintf($$, "{\n%s\nreturn 0;\n}", $2);
        free($2);
    }
    ;

block:
    MUSCLE stmts BONE
    {
        $$ = malloc(strlen($2) + 5);
        sprintf($$, "{\n%s\n}", $2);
        free($2);
    }
    ;

stmts:
    { $$ = strdup(""); }
    | stmts stmt
    {
        $$ = malloc(strlen($1) + strlen($2) + 2);
        sprintf($$, "%s%s\n", $1, $2);
        free($1); free($2);
    }
    ;

semicolon:
    TRULER { $$ = strdup(";"); }
    ;

stmt:
    decl semicolon
    {
        $$ = malloc(strlen($1) + strlen($2) + 1);
        sprintf($$, "%s%s", $1, $2);
        free($1); free($2);
    }
    | assign semicolon
    {
        $$ = malloc(strlen($1) + strlen($2) + 1);
        sprintf($$, "%s%s", $1, $2);
        free($1); free($2);
    }
    | print semicolon
    {
        $$ = malloc(strlen($1) + strlen($2) + 1);
        sprintf($$, "%s%s", $1, $2);
        free($1); free($2);
    }
    | input semicolon
    {
        $$ = malloc(strlen($1) + strlen($2) + 1);
        sprintf($$, "%s%s", $1, $2);
        free($1); free($2);
    }
    | ret semicolon
    {
        $$ = malloc(strlen($1) + strlen($2) + 1);
        sprintf($$, "%s%s", $1, $2);
        free($1); free($2);
    }
    | CTRL semicolon
    {
        $$ = malloc(strlen($1) + strlen($2) + 1);
        sprintf($$, "%s%s", $1, $2);
        free($1); free($2);
    }
    | cond_stmt
    {
        $$ = $1;
    }
    | loop
    {
        $$ = $1;
    }
    | functionCall semicolon
    {
        $$ = malloc(strlen($1) + strlen($2) + 1);
        sprintf($$, "%s%s", $1, $2);
        free($1); free($2);
    }
    ;

functionCall:
    IDENT HEART callParams BROKEN_HEART
    {
        $$ = malloc(strlen($1) + strlen($3) + 3);
        sprintf($$, "%s(%s)", $1, $3);
        free($1); free($3);
    }
    ;

callParams:
    { $$ = strdup("");}
    | exprList { $$ = $1; }
    ;

exprList:
    expr
    {
        $$ = strdup($1);
        free($1);
    }
    | exprList TRULER expr
    {
        $$ = malloc(strlen($1) + strlen($3) + 3);
        sprintf($$, "%s, %s", $1, $3);
        free($1); free($3);
    }
    ;

array_decl:
    type LOCOMOTIVE NUMBER IDENT
    {
        $$ = malloc(strlen($1) + strlen($4) + 10);
        sprintf($$, "%s %s[%d]", $1, $4, $3);   // int numbers[5]
        free($1); free($4);
    }
    | type LOCOMOTIVE NUMBER IDENT ZAP array_init
    {
        $$ = malloc(strlen($1) + strlen($4) + strlen($6) + 15);
        sprintf($$, "%s %s[%d] = %s", $1, $4, $3, $6);  // int numbers[5] = {1,2,3}
        free($1); free($4); free($6);
    }
    | type LOCOMOTIVE IDENT ZAP array_init
    {
        // Определяем размер по количеству элементов
        // Нужно посчитать элементы в array_init
        // Пока просто делаем [] - компилятор C сам определит
        $$ = malloc(strlen($1) + strlen($3) + strlen($5) + 10);
        sprintf($$, "%s %s[] = %s", $1, $3, $5);  // int numbers[] = {1,2,3}
        free($1); free($3); free($5);
    }
    /* ДВУМЕРНЫЕ МАССИВЫ */
    | type LOCOMOTIVE NUMBER LOCOMOTIVE NUMBER IDENT
    {
        $$ = malloc(strlen($1) + strlen($6) + 15); // + strlen($3) + strlen($5)
        sprintf($$, "%s %s[%d][%d]", $1, $6, $3, $5);  // int matrix[3][4]
        free($1); free($6); //free($3); free($5);
    }
    | type LOCOMOTIVE NUMBER LOCOMOTIVE NUMBER IDENT ZAP array_init
    {
        // Для простоты - инициализация только первого измерения
        $$ = malloc(strlen($1) + strlen($6) + strlen($8) + 20);
        sprintf($$, "%s %s[%d][%d] = %s", $1, $6, $3, $5, $8);
        free($1); free($6); free($8);//free($3); free($5); free($8);
    }

    | type LOCOMOTIVE IDENT LOCOMOTIVE IDENT IDENT
    {
        $$ = malloc(strlen($1) +  strlen($3) + strlen($5) + strlen($6) + 15); // + strlen($3) + strlen($5)
        sprintf($$, "%s %s[%s][%s]", $1, $6, $3, $5);  // int matrix[3][4]
        free($1); free($6); free($3); free($5);//free($3); free($5);
    }
    | type LOCOMOTIVE IDENT LOCOMOTIVE IDENT IDENT ZAP array_init
    {
        // Для простоты - инициализация только первого измерения
        $$ = malloc(strlen($1) + strlen($6) +  strlen($3) + strlen($5) + strlen($8) + 20);
        sprintf($$, "%s %s[%s][%s] = %s", $1, $6, $3, $5, $8);
        free($1); free($6); free($8); free($3); free($5);//free($3); free($5); free($8);
    }
    ;

array_init:
    MUSCLE BONE
    {
        $$ = strdup("{}");
    }
    |
    MUSCLE exprList BONE
    {
        $$ = malloc(strlen($2) + 3);
        sprintf($$, "{%s}", $2);
        free($2);
    }
    ;

decl:
    type IDENT
    {
        $$ = malloc(strlen($1) + strlen($2) + 2);
        sprintf($$, "%s %s", $1, $2);
        free($1); free($2);
    }
    | type IDENT ZAP expr
    {
        $$ = malloc(strlen($1) + strlen($2) + strlen($4) + 4);
        sprintf($$, "%s %s = %s", $1, $2, $4);
        free($1); free($2); free($4);
    }
    | array_decl
    {
        $$ = $1;
    }
    ;


//array_access:
//   expr
//    {
//        $$ = malloc(strlen($1) + 4);
//        sprintf($$, "[%s]", $1);
//        free($1);
//    }
//    | array_access RAILWAY_TRACK expr RAILWAY_TRACK
//    {
//        $$ = malloc(strlen($1) + strlen($3) + 4);
//        sprintf($$, "%s[%s]", $1, $3);
//        free($1); free($3);
//    }
//    ;

/*array_access:
    RAILWAY_TRACK expr RAILWAY_TRACK %prec RAILWAY_TRACK
    {
        $$ = malloc(strlen($2) + 3);
        sprintf($$, "[%s]", $2);
        free($2);
    }
    | array_access RAILWAY_TRACK expr RAILWAY_TRACK %prec RAILWAY_TRACK
    {
        $$ = malloc(strlen($1) + strlen($3) + 3);
        sprintf($$, "%s[%s]", $1, $3);
        free($1); free($3);
    }
    ;*/

array_index_chain:
    RAILWAY_TRACK expr RAILWAY_TRACK
    {
        $$ = malloc(strlen($2) + 3);
        sprintf($$, "[%s]", $2);
        free($2);
    }
    | array_index_chain RAILWAY_TRACK expr RAILWAY_TRACK
    {
        $$ = malloc(strlen($1) + strlen($3) + 3);
        sprintf($$, "%s[%s]", $1, $3);
        free($1); free($3);
    }
    ;

assign:
    IDENT ZAP expr
    {
        $$ = malloc(strlen($1) + strlen($3) + 4);
        sprintf($$, "%s = %s", $1, $3);
        free($1); free($3);
    }
    | CHAK IDENT array_index_chain ZAP expr  //primary
    {
        $$ = malloc(strlen($2) + strlen($3) + strlen($5) + 5);
        sprintf($$, "%s%s = %s", $2, $3, $5);
        free($2); free($3); free($5);
    }
    ;

cond_stmt:
    DART HEART expr BROKEN_HEART block %prec LOWER_THAN_ELSE
    {
        $$ = malloc(strlen($3) + strlen($5) + 8);
        sprintf($$, "if (%s) %s", $3, $5);
        free($3); free($5);
    }
    | DART HEART expr BROKEN_HEART block SKULL cond_stmt
    {
        $$ = malloc(strlen($3) + strlen($5) + strlen($7) + 15);
        sprintf($$, "if (%s) %s else %s", $3, $5, $7);
        free($3); free($5); free($7);
    }
    | DART HEART expr BROKEN_HEART block SKULL block
    {
        $$ = malloc(strlen($3) + strlen($5) + strlen($7) + 13);
        sprintf($$, "if (%s) %s else %s", $3, $5, $7);
        free($3); free($5); free($7);
    }
    ;

loop:
    CYCLONE HEART init semicolon cond_expr semicolon step BROKEN_HEART block
    {
        $$ = malloc(strlen($3) + strlen($5) + strlen($7) + strlen($9) + 15);
        sprintf($$, "for (%s; %s; %s) %s", $3, $5, $7, $9);
        free($3); free($5); free($7); free($9);
    }
    | INFINITY HEART expr BROKEN_HEART block
    {
        $$ = malloc(strlen($3) + strlen($5) + 11);
        sprintf($$, "while (%s) %s", $3, $5);
        free($3); free($5);
    }
    | range_loop
    {
        $$ = $1;
    }
    | foreach_loop
    {
        $$ = $1;
    }
    ;

range_loop:
    /*start..end*/
    CYCLONE HEART IDENT IN expr DOTDOT expr BROKEN_HEART block
    {
        $$ = malloc(strlen($3) + strlen($5) + strlen($7) + strlen($9) + 50);
        sprintf($$, "for (int %s = %s; %s <= %s; %s++) %s",
                $3, $5, $3, $7, $3, $9);
        free($3); free($5); free($7); free($9);
    }
    /*start..<end*/
    | CYCLONE HEART IDENT IN expr DOTDOTLT expr BROKEN_HEART block
    {
        $$ = malloc(strlen($3) + strlen($5) + strlen($7) + strlen($9) + 50);
        sprintf($$, "for (int %s = %s; %s < %s; %s++) %s",
                $3, $5, $3, $7, $3, $9);
        free($3); free($5); free($7); free($9);
    }
    /*start..end:step */
    | CYCLONE HEART IDENT IN expr DOTDOT expr STEP expr BROKEN_HEART block
    {
        $$ = malloc(strlen($3) + strlen($5) + strlen($7) + strlen($9) + strlen($11) + 60);
        sprintf($$, "for (int %s = %s; %s <= %s; %s += %s) %s",
                $3, $5, $3, $7, $3, $9, $11);
        free($3); free($5); free($7); free($9); free($11);
    }
    ;

foreach_loop:
    STEAM_LOCOMOTIVE HEART type IDENT IN IDENT BROKEN_HEART MUSCLE stmts BONE
    {
        $$ = malloc(strlen($3) + strlen($4) + strlen($6) + strlen($9) + 120);
        sprintf($$, "for (int __i = 0; __i < sizeof(%s)/sizeof(%s[0]); __i++) {\n%s %s = %s[__i];\n%s\n}",
                $6, $6, $3, $4, $6, $9);
        free($3); free($4); free($6); free($9);
    }
    ;

init:
    type IDENT ZAP expr
    {
        $$ = malloc(strlen($1) + strlen($2) + strlen($4) + 5);
        sprintf($$, "%s %s = %s", $1, $2, $4);
        free($1); free($2); free($4);
    }
    | IDENT ZAP expr
    {
        $$ = malloc(strlen($1) + strlen($3) + 2);
        sprintf($$, "%s = %s", $1, $3);
        free($1); free($3);
    }
    ;

cond_expr: expr { $$ = $1; };
step: 
    IDENT ZAP expr
    {
        $$ = malloc(strlen($1) + strlen($3) + 4);
        sprintf($$, "%s = %s", $1, $3);
        free($1); free($3);
    }
    ;
//expr { $$ = $1; };

//print:
//    MEGA HEART printItems BROKEN_HEART
//    {
//        $$ = malloc(strlen($3) + 10);
//        sprintf($$, "printf(%s)", $3);
//       free($3);
//    }
//    ;

print:
    MEGA HEART printItems BROKEN_HEART
    {
        $$ = malloc(strlen($3) + 20);
        sprintf($$, "%s;", $3);
        free($3);
    }
    ;

printItems:
    printItem
    {
        $$ = $1;
    }
    | printItems TRULER printItem
    {
        $$ = malloc(strlen($1) + strlen($3) + 3);
        sprintf($$, "%s;\n%s", $1, $3);
        free($1); free($3);
    }
    ;

printItem:
    STRING
    {
        // Просто строка: "Hello" → printf("Hello");
        $$ = malloc(strlen($1) + 12);
        sprintf($$, "printf(%s)", $1);
        free($1);
    }
    | type expr
    {
        // Значение с типом: int x → printf("%d", x);
        char* format;
        if (strcmp($1, "int") == 0) format = "\"%d\"";
        else if (strcmp($1, "double") == 0) format = "\"%f\"";
        else if (strcmp($1, "char") == 0) format = "\"%c\"";
        else if (strcmp($1, "char*") == 0) format = "\"%s\"";
        else if (strcmp($1, "bool") == 0) {
            // bool → printf("%s", x ? "true" : "false");
            $$ = malloc(strlen($2) + 50);
            sprintf($$, "printf(\"%%s\", %s ? \"true\" : \"false\")", $2);
            free($1); free($2);
            return;                                 //это закоментировать
        }
        else format = "\"%d\"";
        
        //if (strcmp($1, "bool") == 1){             это раскоментировать
        $$ = malloc(strlen(format) + strlen($2) + 13);
        sprintf($$, "printf(%s, %s)", format, $2);
        free($1); free($2);
        //}                                         это раскоментировать
    }
    ;

input:
    EAR HEART STRING TRULER type IDENT BROKEN_HEART
    {
        const char* format;
        const char* ampersand = "&";
        
        if (strcmp($5, "int") == 0) format = "%d";
        else if (strcmp($5, "double") == 0) format = "%lf";
        else if (strcmp($5, "float") == 0) format = "%f";
        else if (strcmp($5, "char") == 0) format = " %c";
        else if (strcmp($5, "char*") == 0 || strcmp($5, "char *") == 0) {
            format = "%s";
            ampersand = "";
        }
        else if (strcmp($5, "bool") == 0) {
            format = "%d";
        }
        else {
            format = "%s";
        }
        
        $$ = malloc(strlen($3) + strlen($6) + strlen(format) + 50);
        sprintf($$, "printf(%s); scanf(\"%s\", %s%s)", 
                $3, format, ampersand, $6);
        free($3); free($5); free($6);
    }
    ;

ret:
    BACK
    {
        $$ = strdup("return");
    }
    | BACK expr
    {
        $$ = malloc(strlen($2) + 8);
        sprintf($$, "return %s", $2);
        free($2);
    }
    ;

CTRL:
    COLLISION { $$ = strdup("break"); }
    | LOOP { $$ = strdup("continue"); }
    ;

expr:
    primary
    {
        $$ = $1;
    }
    | expr RAILWAY_TRACK expr RAILWAY_TRACK %prec ARRAY_INDEX
    {
        $$ = malloc(strlen($1) + strlen($3) + 4);
        sprintf($$, "%s[%s]", $1, $3);
        free($1); free($3);
    }
    //| IDENT array_index_chain  %prec RAILWAY_TRACK
    //{
    //    $$ = malloc(strlen($1) + strlen($2) + 1);
    //    sprintf($$, "%s%s", $1, $2);
    //    free($1); free($2);
    //}

    | NO_ENTRY expr                          /* !expr */
    {
        $$ = malloc(strlen($2) + 3);
        sprintf($$, "!%s", $2);
        free($2);
    }
    | expr STAR expr                         /* * */
    {
        $$ = malloc(strlen($1) + strlen($3) + 4);
        sprintf($$, "%s * %s", $1, $3);
        free($1); free($3);
    }
    | expr DROPLET expr                      /* / */
    {
        $$ = malloc(strlen($1) + strlen($3) + 4);
        sprintf($$, "%s / %s", $1, $3);
        free($1); free($3);
    }
    | expr BOOM expr                         /* + */
    {
        $$ = malloc(strlen($1) + strlen($3) + 4);
        sprintf($$, "%s + %s", $1, $3);
        free($1); free($3);
    }
    | expr SHIELD expr                       /* - */
    {
        $$ = malloc(strlen($1) + strlen($3) + 4);
        sprintf($$, "%s - %s", $1, $3);
        free($1); free($3);
    }
    | expr SUN expr                          /* > */
    {
        $$ = malloc(strlen($1) + strlen($3) + 4);
        sprintf($$, "%s > %s", $1, $3);
        free($1); free($3);
    }
    | expr MOON expr                         /* < */
    {
        $$ = malloc(strlen($1) + strlen($3) + 4);
        sprintf($$, "%s < %s", $1, $3);
        free($1); free($3);
    }
    | expr FIRE expr                         /* == */
    {
        $$ = malloc(strlen($1) + strlen($3) + 5);
        sprintf($$, "%s == %s", $1, $3);
        free($1); free($3);
    }
    | expr SNOWFLAKE expr                    /* != */
    {
        $$ = malloc(strlen($1) + strlen($3) + 5);
        sprintf($$, "%s != %s", $1, $3);
        free($1); free($3);
    }
    | expr BULB expr                         /* && */
    {
        $$ = malloc(strlen($1) + strlen($3) + 6);
        sprintf($$, "%s && %s", $1, $3);
        free($1); free($3);
    }
    | expr LINK expr                         /* || */
    {
        $$ = malloc(strlen($1) + strlen($3) + 6);
        sprintf($$, "%s || %s", $1, $3);
        free($1); free($3);
    }
    | SIN HEART expr BROKEN_HEART
    {
        $$ = malloc(strlen($3) + 10);
        sprintf($$, "sin(%s)", $3);
        free($3);
    }
    | COS HEART expr BROKEN_HEART
    {
        $$ = malloc(strlen($3) + 10);
        sprintf($$, "cos(%s)", $3);
        free($3);
    }
    ;

primary:
    NUMBER
    {
        $$ = malloc(20);
        sprintf($$, "%d", $1);
    }
    | FLOAT
    {
        $$ = malloc(20);
        sprintf($$, "%f", $1);
    }
    | IDENT
    {
        $$ = strdup($1);
        free($1);
    }
    | STRING
    {
        $$ = strdup($1);
        free($1);
    }
    | CHAR
    {
        $$ = strdup($1);
        free($1);
    }
    | TRUE { $$ = strdup("true"); }
    | FALSE { $$ = strdup("false"); }
    | HEART expr BROKEN_HEART
    {
        $$ = malloc(strlen($2) + 3);
        sprintf($$, "(%s)", $2);
        free($2);
    }
    | functionCall
    {
        $$ = $1;
    }
    ;


%%

void yyerror(const char *s) {
    //fprintf(stderr, "Syntax error at line %d: %s\n", lineno, s);

    //extern int yynerrs;     // Счетчик ошибок
    //extern char *yytext;    // Текст текущего токена
    //extern int lineno;

    // Увеличиваем счетчик ошибок (Bison делает это автоматически после yyerror)
    // Но мы можем использовать текущее значение + 1
    
    //fprintf(stderr, "\nError #%d ", yynerrs + 1);
    //fprintf(stderr, "\nError #%d ", yynerrs);
    /*fprintf(stderr, "\n[Line %d]", lineno);
    fprintf(stderr, "\nError ");
    fprintf(stderr, "%s\n", s);
    if (yytext && strlen(yytext) > 0) {
        fprintf(stderr, "Unexpected symbol: '%s'\n", yytext);
    }*/

    extern char *yytext;
    fprintf(stderr, "[Line %d] %s\n", yylineno, s);
    if (yytext) fprintf(stderr, "At symbol: '%s'\n", yytext);
    
}

int main(int argc, char **argv) {
    if (argc > 1) {
        /* Чтение из файла */
        yyin = fopen(argv[1], "r");
        if (!yyin) {
            fprintf(stderr, "Error: Cannot open file '%s'\n", argv[1]);
            return 1;
        }
    } else {
        /* Чтение из stdin (по умолчанию) */
        yyin = stdin;
    }
    
    //lineno = 1;
    
    int result = yyparse();
    
    if (yyin != stdin) {
        fclose(yyin);
    }
    
    if (result != 0) {
        fprintf(stderr, "Compilation failed\n");
    }
    
    return result;
}