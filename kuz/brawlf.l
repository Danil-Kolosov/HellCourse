%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "brawlf.tab.h"

void yyerror(const char *s);
//int lineno = 1;
%}

%option noyywrap          
%option case-insensitive
%option yylineno

DIGIT   [0-9]
ID      [a-zA-Z_][a-zA-Z0-9_]*
WS      [ \t\r]

%%

[\n]            { }

":primo:"       { return PRIMO; }
":gem:"         { return GEM; }
":note:"        { return NOTE; }
":brain:"       { return BRAIN; }
":sparkles:"    { return SPARKLES; }
"ğŸ”¢"            { return PRIMO; }
"ğŸ’"            { return GEM; }
"ğŸµ"            { return NOTE; }
"ğŸ§ "            { return BRAIN; }
"âœ¨"            { return SPARKLES; }

":boom:"        { return BOOM; }
":shield:"      { return SHIELD; }
":star:"        { return STAR; }
":droplet:"     { return DROPLET; }
":zap:"         { return ZAP; }
":fire:"        { return FIRE; }
":snowflake:"   { return SNOWFLAKE; }
":sun:"         { return SUN; }
":moon:"        { return MOON; }
":bulb:"        { return BULB; }
":link:"        { return LINK; }
":no_entry:"    { return NO_ENTRY; }
"ğŸ’¥"            { return BOOM; }
"ğŸ›¡ï¸"           { return SHIELD; }
"â­"            { return STAR; }
"ğŸ’§"            { return DROPLET; }
"âš¡"            { return ZAP; }
"ğŸ”¥"            { return FIRE; }
"â„ï¸"           { return SNOWFLAKE; }
"â˜€ï¸"           { return SUN; }
"ğŸŒ™"           { return MOON; }
"ğŸ’¡"            { return BULB; }
"ğŸ”—"            { return LINK; }
"â›”"            { return NO_ENTRY; }

":crown:"       { return CROWN; }
":cyclone:"     { return CYCLONE; }
":infinity:"    { return INFINITY; }
":dart:"        { return DART; }
":skull:"       { return SKULL; }
":collision:"   { return COLLISION; }
":loop:"        { return LOOP; }
"ğŸ‘‘"            { return CROWN; }
"ğŸŒªï¸"           { return CYCLONE; }
"â™¾ï¸"           { return INFINITY; }
"ğŸ¯"            { return DART; }
"ğŸ’€"            { return SKULL; }
"ğŸ›‘"            { return COLLISION; }
"â¿"            { return LOOP; }
"ğŸ”™"            { return BACK; }
"ğŸ‘‰"            { return IN; }

":in:"          { return IN; }
[.][.]          { return DOTDOT; }
[.][.]<         { return DOTDOTLT; }
":step:"        { return STEP; }
"ğŸ¬"            { return STEP; }


":locomotive:"       { return LOCOMOTIVE; }
":steam_locomotive:" { return STEAM_LOCOMOTIVE; }
":railway_track:"    { return RAILWAY_TRACK; }
"ğŸš‚"            { return LOCOMOTIVE; }
"ğŸš‚ğŸš‚"         { return STEAM_LOCOMOTIVE; }
"ğŸ›¤ï¸"           { return RAILWAY_TRACK; }
":chak:"          { return CHAK; }
"ğŸ“¦"            { return CHAK; }


":back:"        { return BACK; }
":ghost:"       { return GHOST; }
"ğŸ‘»"            { return GHOST; }

":mega:"        { return MEGA; }
"ğŸ“¢"            { return MEGA; }
":ear:"         { return EAR; }
"ğŸ‘‚"            { return EAR; }

":sin:"         { return SIN; }
":cos:"         { return COS; }
"ğŸ“‰"            { return SIN; }
"ğŸ“ˆ"            { return COS; }

":heart:"       { return HEART; }
":broken_heart:" { return BROKEN_HEART; }
":muscle:"      { return MUSCLE; }
":bone:"        { return BONE; }
":triangular_ruler:" { return TRULER; }
"â¤ï¸"           { return HEART; }
"ğŸ’”"           { return BROKEN_HEART; }
"ğŸ’ª"           { return MUSCLE; }
"ğŸ¦´"           { return BONE; }
"â˜®"             { return TRULER; }




{DIGIT}+        { yylval.number = atoi(yytext); return NUMBER; }
{DIGIT}+"."{DIGIT}*  { yylval.fnumber = atof(yytext); return FLOAT; }
"true"          { yylval.number = 1; return TRUE; }
"false"         { yylval.number = 0; return FALSE; }
{ID}            { yylval.string = strdup(yytext); return IDENT; }
\"[^"]*\"       { yylval.string = strdup(yytext); return STRING; }
'(\\.|[^'\\])'  { yylval.string = strdup(yytext); return CHAR; }


{WS}            { /* ignore */ }
"//"[^\n]*      { /* ignore */ }


.               { 
    fprintf(stderr, "Lexical error: Invalid character '%s'\n", yytext); 
    return ERROR; 
}

%%